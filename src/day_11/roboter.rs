use super::computer::{
    Computer,
    Reader,
    Writer,
};
use crossbeam_channel::unbounded;
use std::{
    collections::BTreeMap,
    thread,
};

const ROBOT_SOFTWARE: &[isize] = &[
    3,
    8,
    1005,
    8,
    330,
    1106,
    0,
    11,
    0,
    0,
    0,
    104,
    1,
    104,
    0,
    3,
    8,
    102,
    -1,
    8,
    10,
    101,
    1,
    10,
    10,
    4,
    10,
    1008,
    8,
    0,
    10,
    4,
    10,
    102,
    1,
    8,
    29,
    2,
    9,
    4,
    10,
    1006,
    0,
    10,
    1,
    1103,
    17,
    10,
    3,
    8,
    102,
    -1,
    8,
    10,
    101,
    1,
    10,
    10,
    4,
    10,
    108,
    0,
    8,
    10,
    4,
    10,
    101,
    0,
    8,
    61,
    1006,
    0,
    21,
    1006,
    0,
    51,
    3,
    8,
    1002,
    8,
    -1,
    10,
    101,
    1,
    10,
    10,
    4,
    10,
    108,
    1,
    8,
    10,
    4,
    10,
    1001,
    8,
    0,
    89,
    1,
    102,
    19,
    10,
    1,
    1107,
    17,
    10,
    1006,
    0,
    18,
    3,
    8,
    1002,
    8,
    -1,
    10,
    1001,
    10,
    1,
    10,
    4,
    10,
    1008,
    8,
    1,
    10,
    4,
    10,
    1001,
    8,
    0,
    123,
    1,
    9,
    2,
    10,
    2,
    1105,
    10,
    10,
    2,
    103,
    9,
    10,
    2,
    1105,
    15,
    10,
    3,
    8,
    102,
    -1,
    8,
    10,
    1001,
    10,
    1,
    10,
    4,
    10,
    1008,
    8,
    0,
    10,
    4,
    10,
    102,
    1,
    8,
    161,
    3,
    8,
    102,
    -1,
    8,
    10,
    101,
    1,
    10,
    10,
    4,
    10,
    108,
    1,
    8,
    10,
    4,
    10,
    101,
    0,
    8,
    182,
    3,
    8,
    1002,
    8,
    -1,
    10,
    101,
    1,
    10,
    10,
    4,
    10,
    1008,
    8,
    0,
    10,
    4,
    10,
    101,
    0,
    8,
    205,
    2,
    1102,
    6,
    10,
    1006,
    0,
    38,
    2,
    1007,
    20,
    10,
    2,
    1105,
    17,
    10,
    3,
    8,
    102,
    -1,
    8,
    10,
    1001,
    10,
    1,
    10,
    4,
    10,
    108,
    1,
    8,
    10,
    4,
    10,
    1001,
    8,
    0,
    241,
    3,
    8,
    102,
    -1,
    8,
    10,
    101,
    1,
    10,
    10,
    4,
    10,
    108,
    1,
    8,
    10,
    4,
    10,
    101,
    0,
    8,
    263,
    1006,
    0,
    93,
    2,
    5,
    2,
    10,
    2,
    6,
    7,
    10,
    3,
    8,
    102,
    -1,
    8,
    10,
    101,
    1,
    10,
    10,
    4,
    10,
    108,
    0,
    8,
    10,
    4,
    10,
    1001,
    8,
    0,
    296,
    1006,
    0,
    81,
    1006,
    0,
    68,
    1006,
    0,
    76,
    2,
    4,
    4,
    10,
    101,
    1,
    9,
    9,
    1007,
    9,
    1010,
    10,
    1005,
    10,
    15,
    99,
    109,
    652,
    104,
    0,
    104,
    1,
    21102,
    825_594_262_284,
    1,
    1,
    21102,
    347,
    1,
    0,
    1105,
    1,
    451,
    21101,
    0,
    932_855_939_852,
    1,
    21101,
    358,
    0,
    0,
    1106,
    0,
    451,
    3,
    10,
    104,
    0,
    104,
    1,
    3,
    10,
    104,
    0,
    104,
    0,
    3,
    10,
    104,
    0,
    104,
    1,
    3,
    10,
    104,
    0,
    104,
    1,
    3,
    10,
    104,
    0,
    104,
    0,
    3,
    10,
    104,
    0,
    104,
    1,
    21102,
    1,
    235_152_649_255,
    1,
    21101,
    405,
    0,
    0,
    1105,
    1,
    451,
    21102,
    235_350_879_235,
    1,
    1,
    21102,
    416,
    1,
    0,
    1106,
    0,
    451,
    3,
    10,
    104,
    0,
    104,
    0,
    3,
    10,
    104,
    0,
    104,
    0,
    21102,
    988_757_512_972,
    1,
    1,
    21101,
    439,
    0,
    0,
    1106,
    0,
    451,
    21102,
    1,
    988_669_698_828,
    1,
    21101,
    0,
    450,
    0,
    1106,
    0,
    451,
    99,
    109,
    2,
    22101,
    0,
    -1,
    1,
    21102,
    40,
    1,
    2,
    21102,
    1,
    482,
    3,
    21102,
    472,
    1,
    0,
    1106,
    0,
    515,
    109,
    -2,
    2105,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    109,
    2,
    3,
    10,
    204,
    -1,
    1001,
    477,
    478,
    493,
    4,
    0,
    1001,
    477,
    1,
    477,
    108,
    4,
    477,
    10,
    1006,
    10,
    509,
    1101,
    0,
    0,
    477,
    109,
    -2,
    2106,
    0,
    0,
    0,
    109,
    4,
    1202,
    -1,
    1,
    514,
    1207,
    -3,
    0,
    10,
    1006,
    10,
    532,
    21102,
    1,
    0,
    -3,
    21202,
    -3,
    1,
    1,
    21202,
    -2,
    1,
    2,
    21102,
    1,
    1,
    3,
    21102,
    1,
    551,
    0,
    1106,
    0,
    556,
    109,
    -4,
    2105,
    1,
    0,
    109,
    5,
    1207,
    -3,
    1,
    10,
    1006,
    10,
    579,
    2207,
    -4,
    -2,
    10,
    1006,
    10,
    579,
    22101,
    0,
    -4,
    -4,
    1105,
    1,
    647,
    21201,
    -4,
    0,
    1,
    21201,
    -3,
    -1,
    2,
    21202,
    -2,
    2,
    3,
    21102,
    598,
    1,
    0,
    1105,
    1,
    556,
    21202,
    1,
    1,
    -4,
    21101,
    0,
    1,
    -1,
    2207,
    -4,
    -2,
    10,
    1006,
    10,
    617,
    21102,
    1,
    0,
    -1,
    22202,
    -2,
    -1,
    -2,
    2107,
    0,
    -3,
    10,
    1006,
    10,
    639,
    21202,
    -1,
    1,
    1,
    21102,
    1,
    639,
    0,
    105,
    1,
    514,
    21202,
    -2,
    -1,
    -2,
    22201,
    -4,
    -2,
    -4,
    109,
    -5,
    2105,
    1,
    0,
];

#[derive(Debug)]
pub struct Roboter {
    pub canvas: BTreeMap<(isize, isize), Color>,
    facing: Direction,
    position: (isize, isize),
    default_color: Color,
}

impl Default for Roboter {
    fn default() -> Self {
        Self {
            canvas: BTreeMap::default(),
            facing: Direction::Up,
            position: (0, 0),
            default_color: Color::Black,
        }
    }
}

impl Roboter {
    pub fn with_default_color(self, default_color: Color) -> Self {
        Self {
            default_color,
            ..self
        }
    }

    pub fn run(&mut self) {
        let (sender_output, receiver_output) = unbounded();
        let (sender_input, receiver_input) = unbounded();

        thread::spawn(move || {
            let input = Reader::Channel(receiver_input);
            let output = Writer::Channel(sender_output);

            let mut computer = Computer::default()
                .with_software(ROBOT_SOFTWARE.to_vec())
                .with_input(input)
                .with_output(output);

            computer.run().unwrap();
        });

        loop {
            let send_value = self
                .canvas
                .get(&self.position)
                .unwrap_or(&self.default_color);
            sender_input.send(send_value.into()).unwrap();

            if let Ok(color_value) = receiver_output.recv() {
                self.paint(color_value.into());
            } else {
                break;
            }

            if let Ok(turn_value) = receiver_output.recv() {
                self.turn(turn_value.into());
            } else {
                break;
            }

            self.step();
        }
    }

    fn turn(&mut self, direction: Direction) {
        use Direction::*;

        let new_direction = match (&self.facing, direction) {
            (Up, Right) => Right,
            (Right, Right) => Down,
            (Down, Right) => Left,
            (Left, Right) => Up,

            (Up, Left) => Left,
            (Right, Left) => Up,
            (Down, Left) => Right,
            (Left, Left) => Down,

            (_, Up) => Up,
            (_, Down) => Down,
        };

        self.facing = new_direction;
    }

    fn step(&mut self) {
        let step = match &self.facing {
            Direction::Up => (0, -1),
            Direction::Down => (0, 1),
            Direction::Right => (1, 0),
            Direction::Left => (-1, 0),
        };

        self.position.0 += step.0;
        self.position.1 += step.1;
    }

    fn paint(&mut self, color: Color) {
        self.canvas.insert(self.position, color);
    }

    pub fn draw(&self) {
        let mut canvas = super::canvas::Canvas::default();

        for (position, color) in &self.canvas {
            canvas.add_color(position, *color)
        }

        canvas.add_roboter(&self.position, &self.facing);

        canvas.run();
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Copy, Clone)]
pub enum Color {
    Black,
    White,
}

impl From<isize> for Color {
    fn from(i: isize) -> Self {
        match i {
            0 => Self::Black,
            1 => Self::White,
            _ => unreachable!(),
        }
    }
}

impl Into<isize> for &Color {
    fn into(self) -> isize {
        match self {
            Color::Black => 0,
            Color::White => 1,
        }
    }
}

#[derive(Debug)]
pub enum Direction {
    Up,
    Down,
    Left,
    Right,
}

impl From<isize> for Direction {
    fn from(i: isize) -> Self {
        match i {
            0 => Self::Left,
            1 => Self::Right,
            _ => unreachable!(),
        }
    }
}
